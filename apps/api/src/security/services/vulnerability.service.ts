import { db } from '@kiro/database';
import { Inject, Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Cron, CronExpression } from '@nestjs/schedule';
import * as fs from 'fs/promises';
import { WINSTON_MODULE_PROVIDER } from 'nest-winston';
import * as path from 'path';
import { Logger } from 'winston';
import { NotificationService } from '../../common/services/notification.service';

export interface Vulnerability {
  id: string;
  cveId?: string;
  title: string;
  description: string;
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  cvssScore?: number;
  category:
    | 'DEPENDENCY'
    | 'CONFIGURATION'
    | 'CODE'
    | 'INFRASTRUCTURE'
    | 'NETWORK';
  component: string;
  version?: string;
  fixedVersion?: string;
  status: 'OPEN' | 'IN_PROGRESS' | 'FIXED' | 'ACCEPTED_RISK' | 'FALSE_POSITIVE';
  discoveredAt: Date;
  fixedAt?: Date;
  references: string[];
  remediation: string[];
}

export interface ScanResult {
  scanId: string;
  scanType: 'DEPENDENCY' | 'SAST' | 'DAST' | 'INFRASTRUCTURE' | 'CONTAINER';
  status: 'RUNNING' | 'COMPLETED' | 'FAILED';
  startedAt: Date;
  completedAt?: Date;
  vulnerabilities: Vulnerability[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
}

export interface SecurityConfiguration {
  component: string;
  setting: string;
  currentValue: any;
  recommendedValue: any;
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  description: string;
  remediation: string;
}

@Injectable()
export class VulnerabilityService {
  private readonly scanHistory: Map<string, ScanResult> = new Map();

  constructor(
    @Inject(WINSTON_MODULE_PROVIDER)
    private readonly logger: Logger,
    private readonly configService: ConfigService,
    private readonly notificationService: NotificationService
  ) {}

  /**
   * Perform dependency vulnerability scan
   */
  async scanDependencies(): Promise<ScanResult> {
    const scanId = `dep_${Date.now()}`;
    const scanResult: ScanResult = {
      scanId,
      scanType: 'DEPENDENCY',
      status: 'RUNNING',
      startedAt: new Date(),
      vulnerabilities: [],
      summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0 },
    };

    this.scanHistory.set(scanId, scanResult);

    try {
      this.logger.info('Starting dependency vulnerability scan', { scanId });

      // Scan package.json files for known vulnerabilities
      const vulnerabilities = await this.scanPackageFiles();

      // Scan Docker images for vulnerabilities
      const dockerVulns = await this.scanDockerImages();
      vulnerabilities.push(...dockerVulns);

      scanResult.vulnerabilities = vulnerabilities;
      scanResult.summary = this.calculateSummary(vulnerabilities);
      scanResult.status = 'COMPLETED';
      scanResult.completedAt = new Date();

      // Store results in database
      await this.storeScanResults(scanResult);

      // Send notifications for critical vulnerabilities
      await this.notifyCriticalVulnerabilities(scanResult);

      this.logger.info('Dependency scan completed', {
        scanId,
        total: scanResult.summary.total,
        critical: scanResult.summary.critical,
      });

      return scanResult;
    } catch (error) {
      this.logger.error('Dependency scan failed', { error, scanId });
      scanResult.status = 'FAILED';
      scanResult.completedAt = new Date();
      return scanResult;
    }
  }

  /**
   * Perform static application security testing (SAST)
   */
  async performSastScan(): Promise<ScanResult> {
    const scanId = `sast_${Date.now()}`;
    const scanResult: ScanResult = {
      scanId,
      scanType: 'SAST',
      status: 'RUNNING',
      startedAt: new Date(),
      vulnerabilities: [],
      summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0 },
    };

    this.scanHistory.set(scanId, scanResult);

    try {
      this.logger.info('Starting SAST scan', { scanId });

      // Scan TypeScript/JavaScript files for security issues
      const codeVulns = await this.scanSourceCode();

      // Scan configuration files
      const configVulns = await this.scanConfigurationFiles();

      const vulnerabilities = [...codeVulns, ...configVulns];

      scanResult.vulnerabilities = vulnerabilities;
      scanResult.summary = this.calculateSummary(vulnerabilities);
      scanResult.status = 'COMPLETED';
      scanResult.completedAt = new Date();

      await this.storeScanResults(scanResult);
      await this.notifyCriticalVulnerabilities(scanResult);

      this.logger.info('SAST scan completed', {
        scanId,
        total: scanResult.summary.total,
      });

      return scanResult;
    } catch (error) {
      this.logger.error('SAST scan failed', { error, scanId });
      scanResult.status = 'FAILED';
      scanResult.completedAt = new Date();
      return scanResult;
    }
  }

  /**
   * Perform infrastructure security scan
   */
  async scanInfrastructure(): Promise<ScanResult> {
    const scanId = `infra_${Date.now()}`;
    const scanResult: ScanResult = {
      scanId,
      scanType: 'INFRASTRUCTURE',
      status: 'RUNNING',
      startedAt: new Date(),
      vulnerabilities: [],
      summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0 },
    };

    this.scanHistory.set(scanId, scanResult);

    try {
      this.logger.info('Starting infrastructure scan', { scanId });

      // Scan Docker configurations
      const dockerVulns = await this.scanDockerConfigurations();

      // Scan Kubernetes configurations
      const k8sVulns = await this.scanKubernetesConfigurations();

      // Scan database configurations
      const dbVulns = await this.scanDatabaseConfigurations();

      const vulnerabilities = [...dockerVulns, ...k8sVulns, ...dbVulns];

      scanResult.vulnerabilities = vulnerabilities;
      scanResult.summary = this.calculateSummary(vulnerabilities);
      scanResult.status = 'COMPLETED';
      scanResult.completedAt = new Date();

      await this.storeScanResults(scanResult);
      await this.notifyCriticalVulnerabilities(scanResult);

      this.logger.info('Infrastructure scan completed', {
        scanId,
        total: scanResult.summary.total,
      });

      return scanResult;
    } catch (error) {
      this.logger.error('Infrastructure scan failed', { error, scanId });
      scanResult.status = 'FAILED';
      scanResult.completedAt = new Date();
      return scanResult;
    }
  }

  /**
   * Get vulnerability by ID
   */
  async getVulnerability(
    vulnerabilityId: string
  ): Promise<Vulnerability | null> {
    try {
      const [result] = await db.execute(
        `
        SELECT * FROM vulnerabilities WHERE id = $1
      `,
        [vulnerabilityId]
      );

      return result ? this.mapDbToVulnerability(result) : null;
    } catch (error) {
      this.logger.error('Failed to get vulnerability', {
        error,
        vulnerabilityId,
      });
      return null;
    }
  }

  /**
   * Update vulnerability status
   */
  async updateVulnerabilityStatus(
    vulnerabilityId: string,
    status: Vulnerability['status'],
    userId: string,
    notes?: string
  ): Promise<void> {
    try {
      await db.execute(
        `
        UPDATE vulnerabilities
        SET status = $1, updated_at = $2, updated_by = $3, notes = $4
        WHERE id = $5
      `,
        [status, new Date(), userId, notes, vulnerabilityId]
      );

      if (status === 'FIXED') {
        await db.execute(
          `
          UPDATE vulnerabilities SET fixed_at = $1 WHERE id = $2
        `,
          [new Date(), vulnerabilityId]
        );
      }

      this.logger.info('Vulnerability status updated', {
        vulnerabilityId,
        status,
        userId,
      });
    } catch (error) {
      this.logger.error('Failed to update vulnerability status', {
        error,
        vulnerabilityId,
        status,
      });
      throw error;
    }
  }

  /**
   * Get vulnerabilities with filtering
   */
  async getVulnerabilities(
    filters: {
      severity?: string;
      status?: string;
      category?: string;
      component?: string;
      page?: number;
      limit?: number;
    } = {}
  ): Promise<{ data: Vulnerability[]; total: number }> {
    const {
      severity,
      status,
      category,
      component,
      page = 1,
      limit = 50,
    } = filters;
    const offset = (page - 1) * limit;

    try {
      let whereClause = 'WHERE 1=1';
      const params: any[] = [];
      let paramIndex = 1;

      if (severity) {
        whereClause += ` AND severity = $${paramIndex}`;
        params.push(severity);
        paramIndex++;
      }

      if (status) {
        whereClause += ` AND status = $${paramIndex}`;
        params.push(status);
        paramIndex++;
      }

      if (category) {
        whereClause += ` AND category = $${paramIndex}`;
        params.push(category);
        paramIndex++;
      }

      if (component) {
        whereClause += ` AND component ILIKE $${paramIndex}`;
        params.push(`%${component}%`);
        paramIndex++;
      }

      // Get total count
      const [totalResult] = await db.execute(
        `
        SELECT COUNT(*) as count FROM vulnerabilities ${whereClause}
      `,
        params
      );

      // Get data
      const data = await db.execute(
        `
        SELECT * FROM vulnerabilities ${whereClause}
        ORDER BY severity DESC, discovered_at DESC
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `,
        [...params, limit, offset]
      );

      return {
        data: data.map(this.mapDbToVulnerability),
        total: totalResult.count || 0,
      };
    } catch (error) {
      this.logger.error('Failed to get vulnerabilities', { error, filters });
      return { data: [], total: 0 };
    }
  }

  /**
   * Get security configuration recommendations
   */
  async getSecurityConfigurations(): Promise<SecurityConfiguration[]> {
    const configurations: SecurityConfiguration[] = [];

    // Check database configurations
    configurations.push(...(await this.checkDatabaseSecurity()));

    // Check application configurations
    configurations.push(...(await this.checkApplicationSecurity()));

    // Check infrastructure configurations
    configurations.push(...(await this.checkInfrastructureSecurity()));

    return configurations;
  }

  /**
   * Scheduled vulnerability scan
   */
  @Cron(CronExpression.EVERY_DAY_AT_2AM)
  async scheduledVulnerabilityScan(): Promise<void> {
    this.logger.info('Starting scheduled vulnerability scan');

    try {
      // Run dependency scan
      await this.scanDependencies();

      // Run SAST scan
      await this.performSastScan();

      // Run infrastructure scan
      await this.scanInfrastructure();

      this.logger.info('Scheduled vulnerability scan completed');
    } catch (error) {
      this.logger.error('Scheduled vulnerability scan failed', { error });
    }
  }

  /**
   * Generate vulnerability report
   */
  async generateVulnerabilityReport(companyId: string): Promise<{
    summary: any;
    trends: any;
    topVulnerabilities: Vulnerability[];
    recommendations: string[];
  }> {
    try {
      const [summary] = await db.execute(`
        SELECT
          COUNT(*) as total,
          COUNT(CASE WHEN severity = 'CRITICAL' THEN 1 END) as critical,
          COUNT(CASE WHEN severity = 'HIGH' THEN 1 END) as high,
          COUNT(CASE WHEN severity = 'MEDIUM' THEN 1 END) as medium,
          COUNT(CASE WHEN severity = 'LOW' THEN 1 END) as low,
          COUNT(CASE WHEN status = 'OPEN' THEN 1 END) as open,
          COUNT(CASE WHEN status = 'FIXED' THEN 1 END) as fixed
        FROM vulnerabilities
      `);

      const topVulnerabilities = await db.execute(`
        SELECT * FROM vulnerabilities
        WHERE status = 'OPEN'
        ORDER BY
          CASE severity
            WHEN 'CRITICAL' THEN 4
            WHEN 'HIGH' THEN 3
            WHEN 'MEDIUM' THEN 2
            ELSE 1
          END DESC,
          discovered_at DESC
        LIMIT 10
      `);

      const trends = await db.execute(`
        SELECT
          DATE_TRUNC('week', discovered_at) as week,
          COUNT(*) as count,
          severity
        FROM vulnerabilities
        WHERE discovered_at >= NOW() - INTERVAL '12 weeks'
        GROUP BY week, severity
        ORDER BY week DESC
      `);

      return {
        summary,
        trends,
        topVulnerabilities: topVulnerabilities.map(this.mapDbToVulnerability),
        recommendations: this.generateRecommendations(summary),
      };
    } catch (error) {
      this.logger.error('Failed to generate vulnerability report', {
        error,
        companyId,
      });
      throw error;
    }
  }

  /**
   * Scan package files for vulnerabilities
   */
  private async scanPackageFiles(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Read package.json files
      const packageFiles = await this.findPackageFiles();

      for (const packageFile of packageFiles) {
        const packageData = JSON.parse(await fs.readFile(packageFile, 'utf8'));
        const deps = {
          ...packageData.dependencies,
          ...packageData.devDependencies,
        };

        for (const [name, version] of Object.entries(deps)) {
          // Check against known vulnerability database
          const vulns = await this.checkPackageVulnerabilities(
            name,
            version as string
          );
          vulnerabilities.push(...vulns);
        }
      }
    } catch (error) {
      this.logger.error('Failed to scan package files', { error });
    }

    return vulnerabilities;
  }

  private async scanDockerImages(): Promise<Vulnerability[]> {
    // Implement Docker image vulnerability scanning
    return [];
  }

  private async scanSourceCode(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      const sourceFiles = await this.findSourceFiles();

      for (const file of sourceFiles) {
        const content = await fs.readFile(file, 'utf8');
        const fileVulns = this.analyzeSourceFile(file, content);
        vulnerabilities.push(...fileVulns);
      }
    } catch (error) {
      this.logger.error('Failed to scan source code', { error });
    }

    return vulnerabilities;
  }

  private async scanConfigurationFiles(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Check for hardcoded secrets
    const secretPatterns = [
      { pattern: /password\s*=\s*["'][^"']+["']/gi, severity: 'HIGH' as const },
      {
        pattern: /api[_-]?key\s*=\s*["'][^"']+["']/gi,
        severity: 'HIGH' as const,
      },
      { pattern: /secret\s*=\s*["'][^"']+["']/gi, severity: 'HIGH' as const },
      { pattern: /token\s*=\s*["'][^"']+["']/gi, severity: 'MEDIUM' as const },
    ];

    try {
      const configFiles = await this.findConfigFiles();

      for (const file of configFiles) {
        const content = await fs.readFile(file, 'utf8');

        for (const { pattern, severity } of secretPatterns) {
          const matches = content.match(pattern);
          if (matches) {
            vulnerabilities.push({
              id: `secret_${Date.now()}_${Math.random()}`,
              title: 'Hardcoded Secret Detected',
              description: `Potential hardcoded secret found in ${file}`,
              severity,
              category: 'CONFIGURATION',
              component: path.basename(file),
              status: 'OPEN',
              discoveredAt: new Date(),
              references: [],
              remediation: [
                'Move secrets to environment variables',
                'Use a secrets management system',
                'Remove hardcoded credentials from source code',
              ],
            });
          }
        }
      }
    } catch (error) {
      this.logger.error('Failed to scan configuration files', { error });
    }

    return vulnerabilities;
  }

  private async scanDockerConfigurations(): Promise<Vulnerability[]> {
    // Implement Docker configuration scanning
    return [];
  }

  private async scanKubernetesConfigurations(): Promise<Vulnerability[]> {
    // Implement Kubernetes configuration scanning
    return [];
  }

  private async scanDatabaseConfigurations(): Promise<Vulnerability[]> {
    // Implement database configuration scanning
    return [];
  }

  private calculateSummary(vulnerabilities: Vulnerability[]) {
    return {
      total: vulnerabilities.length,
      critical: vulnerabilities.filter(v => v.severity === 'CRITICAL').length,
      high: vulnerabilities.filter(v => v.severity === 'HIGH').length,
      medium: vulnerabilities.filter(v => v.severity === 'MEDIUM').length,
      low: vulnerabilities.filter(v => v.severity === 'LOW').length,
    };
  }

  private async storeScanResults(scanResult: ScanResult): Promise<void> {
    try {
      // Store scan result
      await db.execute(
        `
        INSERT INTO vulnerability_scans (
          scan_id, scan_type, status, started_at, completed_at, summary
        ) VALUES ($1, $2, $3, $4, $5, $6)
      `,
        [
          scanResult.scanId,
          scanResult.scanType,
          scanResult.status,
          scanResult.startedAt,
          scanResult.completedAt,
          JSON.stringify(scanResult.summary),
        ]
      );

      // Store vulnerabilities
      for (const vuln of scanResult.vulnerabilities) {
        await db.execute(
          `
          INSERT INTO vulnerabilities (
            id, cve_id, title, description, severity, category, component,
            version, fixed_version, status, discovered_at, references, remediation
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
          ON CONFLICT (id) DO UPDATE SET
            status = EXCLUDED.status,
            updated_at = NOW()
        `,
          [
            vuln.id,
            vuln.cveId,
            vuln.title,
            vuln.description,
            vuln.severity,
            vuln.category,
            vuln.component,
            vuln.version,
            vuln.fixedVersion,
            vuln.status,
            vuln.discoveredAt,
            JSON.stringify(vuln.references),
            JSON.stringify(vuln.remediation),
          ]
        );
      }
    } catch (error) {
      this.logger.error('Failed to store scan results', {
        error,
        scanId: scanResult.scanId,
      });
    }
  }

  private async notifyCriticalVulnerabilities(
    scanResult: ScanResult
  ): Promise<void> {
    const criticalVulns = scanResult.vulnerabilities.filter(
      v => v.severity === 'CRITICAL'
    );

    if (criticalVulns.length > 0) {
      await this.notificationService.sendVulnerabilityAlert({
        scanId: scanResult.scanId,
        scanType: scanResult.scanType,
        criticalCount: criticalVulns.length,
        vulnerabilities: criticalVulns,
      });
    }
  }

  private async findPackageFiles(): Promise<string[]> {
    // Find all package.json files in the project
    return ['package.json', 'apps/api/package.json', 'apps/web/package.json'];
  }

  private async findSourceFiles(): Promise<string[]> {
    // Find all TypeScript/JavaScript source files
    return [];
  }

  private async findConfigFiles(): Promise<string[]> {
    // Find all configuration files
    return ['.env.example', 'docker-compose.yml', 'k8s/api-deployment.yaml'];
  }

  private async checkPackageVulnerabilities(
    name: string,
    version: string
  ): Promise<Vulnerability[]> {
    // Check package against vulnerability database
    // This would integrate with npm audit, Snyk, or other vulnerability databases
    return [];
  }

  private analyzeSourceFile(
    filePath: string,
    content: string
  ): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    // Check for common security issues
    const securityPatterns = [
      {
        pattern: /eval\s*\(/gi,
        title: 'Use of eval() function',
        severity: 'HIGH' as const,
        description:
          'The eval() function can execute arbitrary code and is a security risk',
      },
      {
        pattern: /innerHTML\s*=/gi,
        title: 'Use of innerHTML',
        severity: 'MEDIUM' as const,
        description:
          'innerHTML can lead to XSS vulnerabilities if user input is not sanitized',
      },
      {
        pattern: /document\.write\s*\(/gi,
        title: 'Use of document.write()',
        severity: 'MEDIUM' as const,
        description: 'document.write() can be exploited for XSS attacks',
      },
    ];

    for (const { pattern, title, severity, description } of securityPatterns) {
      const matches = content.match(pattern);
      if (matches) {
        vulnerabilities.push({
          id: `code_${Date.now()}_${Math.random()}`,
          title,
          description: `${description} in ${filePath}`,
          severity,
          category: 'CODE',
          component: path.basename(filePath),
          status: 'OPEN',
          discoveredAt: new Date(),
          references: [],
          remediation: [
            'Review and replace with safer alternatives',
            'Implement proper input validation and sanitization',
          ],
        });
      }
    }

    return vulnerabilities;
  }

  private async checkDatabaseSecurity(): Promise<SecurityConfiguration[]> {
    // Check database security configurations
    return [];
  }

  private async checkApplicationSecurity(): Promise<SecurityConfiguration[]> {
    // Check application security configurations
    return [];
  }

  private async checkInfrastructureSecurity(): Promise<
    SecurityConfiguration[]
  > {
    // Check infrastructure security configurations
    return [];
  }

  private mapDbToVulnerability(dbRow: any): Vulnerability {
    return {
      id: dbRow.id,
      cveId: dbRow.cve_id,
      title: dbRow.title,
      description: dbRow.description,
      severity: dbRow.severity,
      cvssScore: dbRow.cvss_score,
      category: dbRow.category,
      component: dbRow.component,
      version: dbRow.version,
      fixedVersion: dbRow.fixed_version,
      status: dbRow.status,
      discoveredAt: dbRow.discovered_at,
      fixedAt: dbRow.fixed_at,
      references: JSON.parse(dbRow.references || '[]'),
      remediation: JSON.parse(dbRow.remediation || '[]'),
    };
  }

  private generateRecommendations(summary: any): string[] {
    const recommendations: string[] = [];

    if (summary.critical > 0) {
      recommendations.push('Address critical vulnerabilities immediately');
    }

    if (summary.high > 5) {
      recommendations.push('Prioritize fixing high-severity vulnerabilities');
    }

    if (summary.open > summary.fixed) {
      recommendations.push('Increase focus on vulnerability remediation');
    }

    recommendations.push(
      'Implement automated vulnerability scanning in CI/CD pipeline'
    );
    recommendations.push('Regular security training for development team');

    return recommendations;
  }
}
